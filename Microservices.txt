SpringBoot Microservices
-------------------------------------------------------------------------------------------------------------------------------------
1)Monolithic application :- Creating one project that contains many modules.
2)In case of java finally we get one single jar/war file.
3)In single project we have a collection of multiple modules.
4)One request made by client goes to the server and the server process it and give the response.
Server are multithreaded and can give support to a max to 200 request.It is by default we can change this.
when the request comes to the server the load is on server increases.
1 thread is called as 1 load to server.
we have tomcat server ,jetty server they have max capacity of handling of 200 threads.(default)   
when we increase the capacity only it will not work we have increase the server count also or ram capacity to handle the load.
-----------------------------------------------------------------------------------------------------------------------------------------
Load Balance :- It is distrubuting the load among the servers.
There is a tool in microservices to balance the load of the server.
Instance :- An application running under one server is called as one instance.
Scaling :- It the process of increasing performance of a server.ie fast executing more number of request handling.
we have 2 types of scaling:-
1)Horizontal Scaling :- creating new instance or new server instance.
example:- Run application at 3 servers.
2)vertical scaling:- Increase capacity/configuration of a system.
example :- your system has 8gm ram.you increased to 16gb ram.The performance will increase.
--------------------------------------------------------------------------------------------------------------------------------------------------
LBS =load balancer server.It holds InstanceID ,IP,Port etc of the client.
-----------------------------------------------------------------------------------------------------------------------
Monolithic appliaction advantage
-------------------------------------------------
1)simple to develop.(one technology,framework and code).
2)simple to test end to end using selenium.
3)simple to build and deploy.
4)simple to scale and load balance.
-------------------------------------------------------------------------
Limitation of Monolithic
-------------------------------------------
1)The services are tightly connected.any small modification we have to re-deploy.
2)If there is any bug in one module it may effect the other modules.
3)Adopting new technology is not a easy process.
4)If new modules are added after development it size may increase and the application may become more complex.
5) Testing and debuging will take more time.
---------------------------------------------------------------------------------------------------------------------------
 Microservices Architecture
------------------------------------------------------
1)It is de-coupled Architecture Design pattern.
2)In this one or two services/module behaves like one application or project.
3)In this one service communicates with other using webservices concept.
4)in simple divide monolithic application modules into projects and link them.

Advantage :-
------------------
1)re-deploy of all services not required if we modify any one service code.
2)If one service is not working it will not effect other service.
3)adopting new technology is a easy process.It used webservices to integrate one service with another.
4)Enhance new modules or service will be easy to code and integrate.
5)testing is also easy in this case.

Limitations:-
-------------------------
1)maintaining multiple services and monitering is not a easy process.
2)hardware and networking configurations is required mostly.
3)microservices concept is good only if it a distributed application and has multiple clients.
example:- SBI has many clients.
-->mobile application
-->ATM
-->Internet Banking
4)If application is very big having multiple services and number of users are more then we can use micro-services.
5)It is not required for small application,less user .(example:-restaurants billing s/w ,hospital billing )
6)can can used for large scale application.(amazon,flipcard)
------------------------------------------------------------------------------------------------
SOA :- Service Oriented Architecture
------------------------------------------------------------
It is a intergration of two projects /application which are running in two different server.

Integration types:-
1)Homogeneous integration:- two projects are developed using same language.
2)Hetrogeneous integration.:- two projects are developed using different language.

SOA is a Architecture used to link Homogeneous application.

SOA has 3 components and 3 operations.
Three components are :- Service provider:- Who develops the service writing the logic.
service register:-It holds all the service providers services.
service consumer:- consumer uses the service.

There are 3 operations:-
1)publish:- Read service provider code.
2)find:-Consumer application will communicate and find the service.
3)bind:- It need to define a client code,to makes http request and get httpreponse .

In case any code modification are done in provider then we must re-publish and re-find.
-------------------------------------------------------------------------------------------------------------------------------------
Example of Microservice
------------------------------------------
1)Fare microservice
2)booking microservice
3)Search microservices
4)checkin microservices
to each services to communicate between each other we use RabbitMQ as a messaging listener.

There are different messaging listener present :- 1)RabbitMQ ,2)ActiveMQ ,3)Kafka

we have HTTP listener like :- 1)tomcat server  2)jetty server 3)weblogic server which are embeded in springBoot.

each Microservices are self contained means every microservices should have it own
1)Project code 2)project lib 3)embedded server 4)JVM 5)operating system.

------------------------------------------
1)Microservices uses lightweight protocols such as rest and http.
2)It focuses on decoupling.
3)It uses simple messaging listener.
4)microservices are much better in fault tolerance.
5)Each microservices may have independent databases.
6)Microservices uses Spring Cloud.

Features of Microservices
------------------------------------
1)It supports publish and find operation with Registery server.
publish : provides microservice details to Registery server.
find:able to fetch other microservices from same Registery server.

2)supports Intra communication with other Microservices using any client.

There are 3 different types of clients which communicates between each other.
1)Discovery client/EurekaClient
2)Load balance client
3)Declarative client.

3)Support circuit breaker process
If any MS is throwing exception for continious request then it will stop executing and 
provide alert to the dashboard.

4)API Gateway support
every MS might be running in different servers (IP:Port).we can not give all MS 
URLS to end clients.
There must be single-entry and single-exist point provided.ie called as API Gateway.

5)Register and Discovery server (R&D server)

Every MS must be registered with R&D server.
It means MS will provide details like IP,PORT ,ServiceID ,InstanceID,Load Details etc.

6)Spring cloud Netflix Eureka is software tool provided to implement R&D server.

each MS after coding must be published into R&D server by using key-value 
eureka.client.register-with-eureka=true

each MS should able to fetch into MS details by using key-value 
eureka.client.fetch-register=true

-------------------------------------------------------------------------------------------------
Eureka server : R&D server
register and discovery server :- The microservices are registered here.They communicate between each other by using activeMQ ,Kafka.

1)Client :- it is developed using restAPI.
It will communicate using HTTP and JSON to transfer the data.

2)API Gateway and security for checking the authentication and autherization of the data.

3)Once the authentication and autherization is done it can communicate with the microservices.

4)we have the database to store data or to check the authentication and autherization of the user.

5)ActiveMQ:- It is used to communicate between 2 or more microservice.
example:- we have a MS called BookMyShow when you book a ticket it will communicate with the paytm wallet for money.This communication is done by ActiveMQ,Kafka,RabitMQ.

6)Eureka server:- It is also known as Register and discovery server.
All the microservices are registered here.They are given different portno and IP address to run.
The MS will fetch other MS information present in the container.That is known as discovery or fetching of information.
This eureka server will support Load Balancing.

7)CircuitBreaker (Hystrix) server :- it is used for exception handling.When error is happening continiously it will stop the client from accessing the server.

8)config server :- It has the configuration(IP address,Port no,service id,instance id) of each MS.It will be in the form of key and value pair.

when a client is communicating with a MS an instance is created.as many client want to intract with the MS that many instances will be created.
-----------------------------------------------------------Eureka server---------------------------------------------------
Eureka server:-It run on port no 8761

eureka.client.register-with-eureka=false. (regsitry)

eureka.client.fetch-register=false.(discovery)
--------------------------------------------------------------------
step-1:- file ->new ->spring starter project.
step-2:-create a project and paste the src and pom.xml
step3:-localhost:8761
--------------------------------------------------------------------------------------
client:-
server.port=8866
spring.application.name=ADDRESS-SERVICE
eureka.client.service-url.default-zone=http://localhost:8761/eureka
---------------------------------------------------------------------------------------------------------------
step-1 :- run the eureka server first
step-2 :- Then run the client 
-------------------------------------------------------------------------
example-1
Address Client
---------------------
package com.example.demo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/address")
public class AddressController 
{
@GetMapping("/show")
public String showMsg()
{
	String address="My address is Bangalore";
	System.out.println("Hello welcome to Bangalore");
	return address;
	
}
}
----------------------------------------------------------------------------------
main.java
-----------------
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient  or DiscoveryClient
public class SpringcloudAddressServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringcloudAddressServiceApplication.class, args);
	}

}
---------------------------------------
server.port=8866
spring.application.name=ADDRESS-SERVICE
eureka.client.service-url.default-zone=http://localhost:8761/eureka
-------------------------------------------------------------------------------
Bank client
------------------------
package com.example.demo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/bank")
public class BankController 
{
@GetMapping("/details")
public String showMsg()
{
	String bankdetail="My Bank is SBI";
	System.out.println("Hello welcome to SBI");
	return bankdetail;
	
}
}
--------------------------------------------------------------------------------------------
main.java
-------------------
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class SpringcloudAddressServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringcloudAddressServiceApplication.class, args);
	}

}
---------------------------------------------------
server.port=8877
spring.application.name=BANK-SERVICE
eureka.client.service-url.default-zone=http://localhost:8761/eureka

---------------------------------------------------------------------
Eureka Server
-------------------------
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class SpringcloudEurekaServerDemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringcloudEurekaServerDemoApplication.class, args);
	}

}
----------------------------------------
server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-register=false
-----------------------------------------------------------
Consumer
-------------------
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class SpringcloudAddressServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringcloudAddressServiceApplication.class, args);
	}

}
------------------------------------------------------------------------------
package com.example.demo;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;



@Component
public class ConsumeService {
	@Autowired <--------------------------------1)Autowire DiscoveryClient
	private DiscoveryClient client;
	public String calladdressMethods()
	{                                                               2)It calls getInstances() by passing serviceId of provider and return List
		List<ServiceInstance> list = client.getInstances("ADDRESS-SERVICE");

		ServiceInstance si=list.get(0); 3)Read one ServiceInstance from the list at index#0
		URI uri=si.getUri();		4)read URI from si

		String uri=uri+"/address/show"; 5)add path to URI
		
		RestTemplate rt=new RestTemplate(); 6)RestTemplate call
		
		String x=rt.getForObject(url, String.class);
		
		return x;
	}


	public String callbankMethods() 
	{
		List<ServiceInstance> list1 =client.getInstances("BANK-SERVICE"); 
		ServiceInstance si1=list1.get(0);
			String url1=si1.getUri() +"/bank/details"; 
			RestTemplate rt=new RestTemplate(); 
			String y=rt.getForObject(url1, String.class); 
			return y;

	}


}
-----------------------------------------------------------------------------------
package com.example.demo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import com.example.demo.ConsumeService;
@RestController
@RequestMapping("/cust")
public class AccessController 
{
	@Autowired   <-----------------------------we are accessing the consumeService
	private ConsumeService cons;
	
@GetMapping("/access")
public String showMsg()
{
	String detail="My Address details"+ cons.calladdressMethods();
	String detail1="My Bank details"+ cons.callbankMethods();
		return (detail + " "+detail1);
	
}
}
----------------------------------------------------------------------------------------------------------------------
service provider-----Bank ----showmsg()
service provider-----Address----showmsg()
service consumer----AccessController -----showmsg() in this we combine both bank and address showmsg().
-------------------------------------------------------------------------------------------------------------------------------




 
